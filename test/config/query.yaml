name: query
schema: 'northwind:0.0.2'
test:
  - name: query 1
    lambda: (id) => Products.filter(p => p.id == id)
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT p.ProductID AS id, p.ProductName AS name, p.SupplierID AS
          supplierId, p.CategoryID AS categoryId, p.QuantityPerUnit AS quantity,
          p.UnitPrice AS price, p.UnitsInStock AS inStock, p.UnitsOnOrder AS
          onOrder, p.ReorderLevel AS reorderLevel, p.Discontinued AS
          discontinued FROM Products p WHERE p.ProductID = ? ;
      - dialect: mssql
        sentence: >-
          SELECT p.ProductID AS id, p.ProductName AS name, p.SupplierID AS
          supplierId, p.CategoryID AS categoryId, p.QuantityPerUnit AS quantity,
          p.UnitPrice AS price, p.UnitsInStock AS inStock, p.UnitsOnOrder AS
          onOrder, p.ReorderLevel AS reorderLevel, p.Discontinued AS
          discontinued FROM Products p WHERE p.ProductID = :id ;
      - dialect: mysql
        sentence: >-
          SELECT p.ProductID AS id, p.ProductName AS name, p.SupplierID AS
          supplierId, p.CategoryID AS categoryId, p.QuantityPerUnit AS quantity,
          p.UnitPrice AS price, p.UnitsInStock AS inStock, p.UnitsOnOrder AS
          onOrder, p.ReorderLevel AS reorderLevel, p.Discontinued AS
          discontinued FROM Products p WHERE p.ProductID = ? ;
      - dialect: oracle
        sentence: >-
          SELECT p.ProductID AS id, p.ProductName AS name, p.SupplierID AS
          supplierId, p.CategoryID AS categoryId, p.QuantityPerUnit AS quantity,
          p.UnitPrice AS price, p.UnitsInStock AS inStock, p.UnitsOnOrder AS
          onOrder, p.ReorderLevel AS reorderLevel, p.Discontinued AS
          discontinued FROM Products p WHERE p.ProductID = :id ;
      - dialect: postgres
        sentence: >-
          SELECT p.ProductID AS id, p.ProductName AS name, p.SupplierID AS
          supplierId, p.CategoryID AS categoryId, p.QuantityPerUnit AS quantity,
          p.UnitPrice AS price, p.UnitsInStock AS inStock, p.UnitsOnOrder AS
          onOrder, p.ReorderLevel AS reorderLevel, p.Discontinued AS
          discontinued FROM Products p WHERE p.ProductID = $1 ;
    expression: ' Products.filter(p => p.id == id)'
    model:
      id: integer
      name: string
      supplierId: integer
      categoryId: integer
      quantity: string
      price: decimal
      inStock: decimal
      onOrder: decimal
      reorderLevel: decimal
      discontinued: boolean
  - name: query 2
    lambda: () => Products.map(p => p.category.name)
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName FROM Products p INNER JOIN Categories c ON
          c.CategoryID = p.CategoryID ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName FROM Products p INNER JOIN Categories c ON
          c.CategoryID = p.CategoryID ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName FROM Products p INNER JOIN Categories c ON
          c.CategoryID = p.CategoryID ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName FROM Products p INNER JOIN Categories c ON
          c.CategoryID = p.CategoryID ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName FROM Products p INNER JOIN Categories c ON
          c.CategoryID = p.CategoryID ;
    expression: ' Products.map(p => p.category.name)'
    model:
      name: string
  - name: query 3
    lambda: >-
      () => Products.map(p => ({ category: p.category.name, name: p.name,
      quantity: p.quantity, inStock: p.inStock }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ;
    expression: ' Products.map(p => ({ category: p.category.name, name: p.name, quantity: p.quantity, inStock: p.inStock }))'
    model:
      category: string
      name: string
      quantity: string
      inStock: decimal
  - name: query 4
    lambda: >-
      () => Products.filter(p => p.discontinued != false).map(p => ({ category:
      p.category.name, name: p.name, quantity: p.quantity, inStock: p.inStock
      })).sort(p => [p.category, desc(p.name)])
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE
          p.Discontinued <> FALSE ORDER BY category, name desc ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE
          p.Discontinued <> FALSE ORDER BY category, name desc ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE
          p.Discontinued <> FALSE ORDER BY category, name desc ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE
          p.Discontinued <> FALSE ORDER BY category, name desc ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS name,
          p.QuantityPerUnit AS quantity, p.UnitsInStock AS inStock FROM Products
          p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE
          p.Discontinued <> FALSE ORDER BY category, name desc ;
    expression: ' Products.filter(p => p.discontinued != false).map(p => ({ category: p.category.name, name: p.name, quantity: p.quantity, inStock: p.inStock })).sort(p => [p.category, desc(p.name)])'
    model:
      category: string
      name: string
      quantity: string
      inStock: decimal
  - name: query 5
    lambda: >-
      (minValue, from, to) => OrderDetails.filter(p =>
      between(p.order.shippedDate, from, to) && p.unitPrice > minValue).map(p =>
      ({ category: p.product.category.name, product: p.product.name, unitPrice:
      p.unitPrice, quantity: p.quantity })).sort(p => [p.category, p.product])
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS product,
          o.UnitPrice AS unitPrice, o.Quantity AS quantity FROM `Order Details`
          o INNER JOIN Categories c ON c.CategoryID = p.CategoryID INNER JOIN
          Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Products p ON
          p.ProductID = o.ProductID WHERE (o1.ShippedDate BETWEEN ? AND ? AND
          o.UnitPrice > ?) ORDER BY category, product ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS product,
          o.UnitPrice AS unitPrice, o.Quantity AS quantity FROM [Order Details]
          o INNER JOIN Categories c ON c.CategoryID = p.CategoryID INNER JOIN
          Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Products p ON
          p.ProductID = o.ProductID WHERE (o1.ShippedDate BETWEEN :from AND :to
          AND o.UnitPrice > :minValue) ORDER BY category, product ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS product,
          o.UnitPrice AS unitPrice, o.Quantity AS quantity FROM `Order Details`
          o INNER JOIN Categories c ON c.CategoryID = p.CategoryID INNER JOIN
          Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Products p ON
          p.ProductID = o.ProductID WHERE (o1.ShippedDate BETWEEN ? AND ? AND
          o.UnitPrice > ?) ORDER BY category, product ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS product,
          o.UnitPrice AS unitPrice, o.Quantity AS quantity FROM "Order Details"
          o INNER JOIN Categories c ON c.CategoryID = p.CategoryID INNER JOIN
          Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Products p ON
          p.ProductID = o.ProductID WHERE (o1.ShippedDate BETWEEN :from AND :to
          AND o.UnitPrice > :minValue) ORDER BY category, product ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS category, p.ProductName AS product,
          o.UnitPrice AS unitPrice, o.Quantity AS quantity FROM "Order Details"
          o INNER JOIN Categories c ON c.CategoryID = p.CategoryID INNER JOIN
          Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Products p ON
          p.ProductID = o.ProductID WHERE (o1.ShippedDate BETWEEN $1 AND $2 AND
          o.UnitPrice > $3) ORDER BY category, product ;
    expression: ' OrderDetails.filter(p => between(p.order.shippedDate, from, to) && p.unitPrice > minValue).map(p => ({ category: p.product.category.name, product: p.product.name, unitPrice: p.unitPrice, quantity: p.quantity })).sort(p => [p.category, p.product])'
    model:
      category: string
      product: string
      unitPrice: decimal
      quantity: decimal
  - name: query 6
    lambda: >-
      () => OrderDetails.map(p => ({ order: p.orderId, subTotal:
      sum((p.unitPrice * p.quantity * (1 - p.discount / 100)) * 100) }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT o.OrderID AS order, SUM(((o.UnitPrice * (o.Quantity * (1 -
          (o.Discount / 100)))) * 100)) AS subTotal FROM `Order Details` o GROUP
          BY o.OrderID ;
      - dialect: mssql
        sentence: >-
          SELECT o.OrderID AS order, SUM(((o.UnitPrice * (o.Quantity * (1 -
          (o.Discount / 100)))) * 100)) AS subTotal FROM [Order Details] o GROUP
          BY o.OrderID ;
      - dialect: mysql
        sentence: >-
          SELECT o.OrderID AS order, SUM(((o.UnitPrice * (o.Quantity * (1 -
          (o.Discount / 100)))) * 100)) AS subTotal FROM `Order Details` o GROUP
          BY o.OrderID ;
      - dialect: oracle
        sentence: >-
          SELECT o.OrderID AS order, SUM(((o.UnitPrice * (o.Quantity * (1 -
          (o.Discount / 100)))) * 100)) AS subTotal FROM "Order Details" o GROUP
          BY o.OrderID ;
      - dialect: postgres
        sentence: >-
          SELECT o.OrderID AS order, SUM(((o.UnitPrice * (o.Quantity * (1 -
          (o.Discount / 100)))) * 100)) AS subTotal FROM "Order Details" o GROUP
          BY o.OrderID ;
    expression: ' OrderDetails.map(p => ({ order: p.orderId, subTotal: sum((p.unitPrice * p.quantity * (1 - p.discount / 100)) * 100) }))'
    model:
      order: integer
      subTotal: any
