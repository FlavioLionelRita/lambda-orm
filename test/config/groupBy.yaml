name: groupBy
schema: 'northwind:0.0.2'
test:
  - name: groupBy 1
    lambda: '() => Products.map(p => ({ maxPrice: max(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT MAX(p.UnitPrice) AS maxPrice FROM Products p ;
      - dialect: mssql
        sentence: SELECT MAX(p.UnitPrice) AS maxPrice FROM Products p ;
      - dialect: mysql
        sentence: SELECT MAX(p.UnitPrice) AS maxPrice FROM Products p ;
      - dialect: oracle
        sentence: SELECT MAX(p.UnitPrice) AS maxPrice FROM Products p ;
      - dialect: postgres
        sentence: SELECT MAX(p.UnitPrice) AS maxPrice FROM Products p ;
    expression: ' Products.map(p => ({ maxPrice: max(p.price) }))'
    model:
      maxPrice: any
  - name: groupBy 2
    lambda: '() => Products.map(p => ({ minPrice: min(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT MIN(p.UnitPrice) AS minPrice FROM Products p ;
      - dialect: mssql
        sentence: SELECT MIN(p.UnitPrice) AS minPrice FROM Products p ;
      - dialect: mysql
        sentence: SELECT MIN(p.UnitPrice) AS minPrice FROM Products p ;
      - dialect: oracle
        sentence: SELECT MIN(p.UnitPrice) AS minPrice FROM Products p ;
      - dialect: postgres
        sentence: SELECT MIN(p.UnitPrice) AS minPrice FROM Products p ;
    expression: ' Products.map(p => ({ minPrice: min(p.price) }))'
    model:
      minPrice: any
  - name: groupBy 3
    lambda: '() => Products.map(p => ({ total: sum(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT SUM(p.UnitPrice) AS total FROM Products p ;
      - dialect: mssql
        sentence: SELECT SUM(p.UnitPrice) AS total FROM Products p ;
      - dialect: mysql
        sentence: SELECT SUM(p.UnitPrice) AS total FROM Products p ;
      - dialect: oracle
        sentence: SELECT SUM(p.UnitPrice) AS total FROM Products p ;
      - dialect: postgres
        sentence: SELECT SUM(p.UnitPrice) AS total FROM Products p ;
    expression: ' Products.map(p => ({ total: sum(p.price) }))'
    model:
      total: any
  - name: groupBy 4
    lambda: '() => Products.map(p => ({ average: avg(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT AVG(p.UnitPrice) AS average FROM Products p ;
      - dialect: mssql
        sentence: SELECT AVG(p.UnitPrice) AS average FROM Products p ;
      - dialect: mysql
        sentence: SELECT AVG(p.UnitPrice) AS average FROM Products p ;
      - dialect: oracle
        sentence: SELECT AVG(p.UnitPrice) AS average FROM Products p ;
      - dialect: postgres
        sentence: SELECT AVG(p.UnitPrice) AS average FROM Products p ;
    expression: ' Products.map(p => ({ average: avg(p.price) }))'
    model:
      average: any
  - name: groupBy 5
    lambda: '() => Products.map(p => ({ count: count(1) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT COUNT(1) AS count FROM Products p ;
      - dialect: mssql
        sentence: SELECT COUNT(1) AS count FROM Products p ;
      - dialect: mysql
        sentence: SELECT COUNT(1) AS count FROM Products p ;
      - dialect: oracle
        sentence: SELECT COUNT(1) AS count FROM Products p ;
      - dialect: postgres
        sentence: SELECT COUNT(1) AS count FROM Products p ;
    expression: ' Products.map(p => ({ count: count(1) }))'
    model:
      count: any
  - name: groupBy 6
    lambda: >-
      () => Products.map(p => ({ category: p.categoryId, largestPrice:
      max(p.price) }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT p.CategoryID AS category, MAX(p.UnitPrice) AS largestPrice FROM
          Products p GROUP BY p.CategoryID ;
      - dialect: mssql
        sentence: >-
          SELECT p.CategoryID AS category, MAX(p.UnitPrice) AS largestPrice FROM
          Products p GROUP BY p.CategoryID ;
      - dialect: mysql
        sentence: >-
          SELECT p.CategoryID AS category, MAX(p.UnitPrice) AS largestPrice FROM
          Products p GROUP BY p.CategoryID ;
      - dialect: oracle
        sentence: >-
          SELECT p.CategoryID AS category, MAX(p.UnitPrice) AS largestPrice FROM
          Products p GROUP BY p.CategoryID ;
      - dialect: postgres
        sentence: >-
          SELECT p.CategoryID AS category, MAX(p.UnitPrice) AS largestPrice FROM
          Products p GROUP BY p.CategoryID ;
    expression: ' Products.map(p => ({ category: p.categoryId, largestPrice: max(p.price) }))'
    model:
      category: integer
      largestPrice: any
  - name: groupBy 7
    lambda: >-
      () => Products.map(p => ({ category: p.category.name, largestPrice:
      max(p.price) }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName ;
    expression: ' Products.map(p => ({ category: p.category.name, largestPrice: max(p.price) }))'
    model:
      category: string
      largestPrice: any
  - name: groupBy 8
    lambda: >-
      (id) => Products.filter(p => p.id == id).map(p => ({ name: p.name, source:
      p.price, result: abs(p.price) }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT p.ProductName AS name, p.UnitPrice AS source, ABS(p.UnitPrice)
          AS result FROM Products p WHERE p.ProductID = ? ;
      - dialect: mssql
        sentence: >-
          SELECT p.ProductName AS name, p.UnitPrice AS source, ABS(p.UnitPrice)
          AS result FROM Products p WHERE p.ProductID = :id ;
      - dialect: mysql
        sentence: >-
          SELECT p.ProductName AS name, p.UnitPrice AS source, ABS(p.UnitPrice)
          AS result FROM Products p WHERE p.ProductID = ? ;
      - dialect: oracle
        sentence: >-
          SELECT p.ProductName AS name, p.UnitPrice AS source, ABS(p.UnitPrice)
          AS result FROM Products p WHERE p.ProductID = :id ;
      - dialect: postgres
        sentence: >-
          SELECT p.ProductName AS name, p.UnitPrice AS source, ABS(p.UnitPrice)
          AS result FROM Products p WHERE p.ProductID = $1 ;
    expression: ' Products.filter(p => p.id == id).map(p => ({ name: p.name, source: p.price, result: abs(p.price) }))'
    model:
      name: string
      source: decimal
      result: any
  - name: groupBy 9
    lambda: >-
      () => Products.map(p => ({ category: p.category.name, largestPrice:
      max(p.price) })).having(p => p.largestPrice > 100)
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ;
    expression: ' Products.map(p => ({ category: p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice > 100)'
    model:
      category: string
      largestPrice: any
  - name: groupBy 10
    lambda: >-
      () => Products.map(p => ({ category: p.category.name, largestPrice:
      max(p.price) })).having(p => p.largestPrice > 100).sort(p =>
      desc(p.largestPrice))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER BY
          largestPrice desc ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER BY
          largestPrice desc ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER BY
          largestPrice desc ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER BY
          largestPrice desc ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER BY
          largestPrice desc ;
    expression: ' Products.map(p => ({ category: p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice > 100).sort(p => desc(p.largestPrice))'
    model:
      category: string
      largestPrice: any
  - name: groupBy 11
    lambda: >-
      () => Products.filter(p => p.price > 5).map(p => ({ category:
      p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice
      > 50).sort(p => desc(p.largestPrice))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING largestPrice > 50
          ORDER BY largestPrice desc ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING largestPrice > 50
          ORDER BY largestPrice desc ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING largestPrice > 50
          ORDER BY largestPrice desc ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING largestPrice > 50
          ORDER BY largestPrice desc ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS category, MAX(p.UnitPrice) AS largestPrice
          FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID
          WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING largestPrice > 50
          ORDER BY largestPrice desc ;
    expression: ' Products.filter(p => p.price > 5).map(p => ({ category: p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice > 50).sort(p => desc(p.largestPrice))'
    model:
      category: string
      largestPrice: any
