name: groupBy
schema: 'northwind:0.0.2'
context:
  a:
    id: 1
test:
  - name: groupBy 1
    lambda: '() => Products.map(p => ({ maxPrice: max(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT MAX(p.UnitPrice) AS `maxPrice` FROM Products p ;
      - dialect: mssql
        sentence: 'SELECT MAX(p.UnitPrice) AS [maxPrice] FROM Products p ;'
      - dialect: mysql
        sentence: SELECT MAX(p.UnitPrice) AS `maxPrice` FROM Products p ;
      - dialect: oracle
        sentence: SELECT MAX(p.UnitPrice) AS "maxPrice" FROM Products p ;
      - dialect: postgres
        sentence: SELECT MAX(p.UnitPrice) AS "maxPrice" FROM Products p ;
    errors: 0
    expression: ' Products.map(p => ({ maxPrice: max(p.price) }))'
    model:
      maxPrice: any
    parameters: []
    fields:
      - name: maxPrice
        type: any
    executions:
      - database: mysql
        result:
          - maxPrice: '263.5000'
      - database: postgres
        result:
          - maxPrice: '263.5000'
  - name: groupBy 2
    lambda: '() => Products.map(p => ({ minPrice: min(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT MIN(p.UnitPrice) AS `minPrice` FROM Products p ;
      - dialect: mssql
        sentence: 'SELECT MIN(p.UnitPrice) AS [minPrice] FROM Products p ;'
      - dialect: mysql
        sentence: SELECT MIN(p.UnitPrice) AS `minPrice` FROM Products p ;
      - dialect: oracle
        sentence: SELECT MIN(p.UnitPrice) AS "minPrice" FROM Products p ;
      - dialect: postgres
        sentence: SELECT MIN(p.UnitPrice) AS "minPrice" FROM Products p ;
    errors: 0
    expression: ' Products.map(p => ({ minPrice: min(p.price) }))'
    model:
      minPrice: any
    parameters: []
    fields:
      - name: minPrice
        type: any
    executions:
      - database: mysql
        result:
          - minPrice: '2.5000'
      - database: postgres
        result:
          - minPrice: '2.5000'
  - name: groupBy 3
    lambda: '() => Products.map(p => ({ total: sum(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT SUM(p.UnitPrice) AS `total` FROM Products p ;
      - dialect: mssql
        sentence: 'SELECT SUM(p.UnitPrice) AS [total] FROM Products p ;'
      - dialect: mysql
        sentence: SELECT SUM(p.UnitPrice) AS `total` FROM Products p ;
      - dialect: oracle
        sentence: SELECT SUM(p.UnitPrice) AS "total" FROM Products p ;
      - dialect: postgres
        sentence: SELECT SUM(p.UnitPrice) AS "total" FROM Products p ;
    errors: 0
    expression: ' Products.map(p => ({ total: sum(p.price) }))'
    model:
      total: any
    parameters: []
    fields:
      - name: total
        type: any
    executions:
      - database: mysql
        result:
          - total: '2222.7100'
      - database: postgres
        result:
          - total: '2222.7100'
  - name: groupBy 4
    lambda: '() => Products.map(p => ({ average: avg(p.price) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT AVG(p.UnitPrice) AS `average` FROM Products p ;
      - dialect: mssql
        sentence: 'SELECT AVG(p.UnitPrice) AS [average] FROM Products p ;'
      - dialect: mysql
        sentence: SELECT AVG(p.UnitPrice) AS `average` FROM Products p ;
      - dialect: oracle
        sentence: SELECT AVG(p.UnitPrice) AS "average" FROM Products p ;
      - dialect: postgres
        sentence: SELECT AVG(p.UnitPrice) AS "average" FROM Products p ;
    errors: 0
    expression: ' Products.map(p => ({ average: avg(p.price) }))'
    model:
      average: any
    parameters: []
    fields:
      - name: average
        type: any
    executions:
      - database: mysql
        result:
          - average: '28.86636364'
      - database: postgres
        result:
          - average: '28.8663636363636364'
  - name: groupBy 5
    lambda: '() => Products.map(p => ({ count: count(1) }))'
    sentences:
      - dialect: mariadb
        sentence: SELECT COUNT(1) AS `count` FROM Products p ;
      - dialect: mssql
        sentence: 'SELECT COUNT(1) AS [count] FROM Products p ;'
      - dialect: mysql
        sentence: SELECT COUNT(1) AS `count` FROM Products p ;
      - dialect: oracle
        sentence: SELECT COUNT(1) AS "count" FROM Products p ;
      - dialect: postgres
        sentence: SELECT COUNT(1) AS "count" FROM Products p ;
    errors: 0
    expression: ' Products.map(p => ({ count: count(1) }))'
    model:
      count: any
    parameters: []
    fields:
      - name: count
        type: any
    executions:
      - database: mysql
        result:
          - count: 77
      - database: postgres
        result:
          - count: '77'
  - name: groupBy 6
    lambda: >-
      () => Products.map(p => ({ category: p.categoryId, largestPrice:
      max(p.price) }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT p.CategoryID AS `category`, MAX(p.UnitPrice) AS `largestPrice`
          FROM Products p GROUP BY p.CategoryID ;
      - dialect: mssql
        sentence: >-
          SELECT p.CategoryID AS [category], MAX(p.UnitPrice) AS [largestPrice]
          FROM Products p GROUP BY p.CategoryID ;
      - dialect: mysql
        sentence: >-
          SELECT p.CategoryID AS `category`, MAX(p.UnitPrice) AS `largestPrice`
          FROM Products p GROUP BY p.CategoryID ;
      - dialect: oracle
        sentence: >-
          SELECT p.CategoryID AS "category", MAX(p.UnitPrice) AS "largestPrice"
          FROM Products p GROUP BY p.CategoryID ;
      - dialect: postgres
        sentence: >-
          SELECT p.CategoryID AS "category", MAX(p.UnitPrice) AS "largestPrice"
          FROM Products p GROUP BY p.CategoryID ;
    errors: 0
    expression: ' Products.map(p => ({ category: p.categoryId, largestPrice: max(p.price) }))'
    model:
      category: integer
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: integer
      - name: largestPrice
        type: any
    executions:
      - database: mysql
        result:
          - category: 1
            largestPrice: '263.5000'
          - category: 2
            largestPrice: '43.9000'
          - category: 3
            largestPrice: '81.0000'
          - category: 4
            largestPrice: '55.0000'
          - category: 5
            largestPrice: '38.0000'
          - category: 6
            largestPrice: '123.7900'
          - category: 7
            largestPrice: '53.0000'
          - category: 8
            largestPrice: '62.5000'
      - database: postgres
        result:
          - category: 3
            largestPrice: '81.0000'
          - category: 5
            largestPrice: '38.0000'
          - category: 4
            largestPrice: '55.0000'
          - category: 6
            largestPrice: '123.7900'
          - category: 2
            largestPrice: '43.9000'
          - category: 7
            largestPrice: '53.0000'
          - category: 1
            largestPrice: '263.5000'
          - category: 8
            largestPrice: '62.5000'
  - name: groupBy 7
    lambda: >-
      () => Products.map(p => ({ category: p.category.name, largestPrice:
      max(p.price) }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(p.UnitPrice) AS
          [largestPrice] FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName ;
    errors: 0
    expression: ' Products.map(p => ({ category: p.category.name, largestPrice: max(p.price) }))'
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
        result:
          - category: Beverages
            largestPrice: '263.5000'
          - category: Condiments
            largestPrice: '43.9000'
          - category: Confections
            largestPrice: '81.0000'
          - category: Dairy Products
            largestPrice: '55.0000'
          - category: Grains/Cereals
            largestPrice: '38.0000'
          - category: Meat/Poultry
            largestPrice: '123.7900'
          - category: Produce
            largestPrice: '53.0000'
          - category: Seafood
            largestPrice: '62.5000'
      - database: postgres
        result:
          - category: Grains/Cereals
            largestPrice: '38.0000'
          - category: Beverages
            largestPrice: '263.5000'
          - category: Dairy Products
            largestPrice: '55.0000'
          - category: Seafood
            largestPrice: '62.5000'
          - category: Produce
            largestPrice: '53.0000'
          - category: Condiments
            largestPrice: '43.9000'
          - category: Meat/Poultry
            largestPrice: '123.7900'
          - category: Confections
            largestPrice: '81.0000'
  - name: groupBy 8
    context: a
    lambda: >-
      (id) => Products.filter(p => p.id == id).map(p => ({ name: p.name, source:
      p.price, result: abs(p.price) }))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT p.ProductName AS `name`, p.UnitPrice AS `source`,
          ABS(p.UnitPrice) AS `result` FROM Products p WHERE p.ProductID = ? ;
      - dialect: mssql
        sentence: >-
          SELECT p.ProductName AS [name], p.UnitPrice AS [source],
          ABS(p.UnitPrice) AS [result] FROM Products p WHERE p.ProductID = :id ;
      - dialect: mysql
        sentence: >-
          SELECT p.ProductName AS `name`, p.UnitPrice AS `source`,
          ABS(p.UnitPrice) AS `result` FROM Products p WHERE p.ProductID = ? ;
      - dialect: oracle
        sentence: >-
          SELECT p.ProductName AS "name", p.UnitPrice AS "source",
          ABS(p.UnitPrice) AS "result" FROM Products p WHERE p.ProductID = :id ;
      - dialect: postgres
        sentence: >-
          SELECT p.ProductName AS "name", p.UnitPrice AS "source",
          ABS(p.UnitPrice) AS "result" FROM Products p WHERE p.ProductID = $1 ;
    errors: 0
    expression: ' Products.filter(p => p.id == id).map(p => ({ name: p.name, source: p.price, result: abs(p.price) }))'
    model:
      name: string
      source: decimal
      result: any
    parameters:
      - name: id
        type: integer
        value: 1
    fields:
      - name: name
        type: string
      - name: source
        type: decimal
      - name: result
        type: any
    executions:
      - database: mysql
        result:
          - name: Chai
            source: '18.0000'
            result: '18.0000'
      - database: postgres
        result:
          - name: Chai
            source: '18.0000'
            result: '18.0000'
  - name: groupBy 9
    lambda: >-
      () => Products.map(p => ({ category: p.category.name, largestPrice:
      max(p.price) })).having(p => p.largestPrice > 100)
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(p.UnitPrice) AS
          [largestPrice] FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ;
    errors: 1
    expression: ' Products.map(p => ({ category: p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice > 100)'
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
        result:
          - category: Beverages
            largestPrice: '263.5000'
          - category: Meat/Poultry
            largestPrice: '123.7900'
      - database: postgres
        error: 'run: select error: TypeError: Cannot read property ''rows'' of undefined'
  - name: groupBy 10
    lambda: >-
      () => Products.map(p => ({ category: p.category.name, largestPrice:
      max(p.price) })).having(p => p.largestPrice > 100).sort(p =>
      desc(p.largestPrice))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER
          BY largestPrice desc ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(p.UnitPrice) AS
          [largestPrice] FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER
          BY largestPrice desc ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER
          BY largestPrice desc ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER
          BY largestPrice desc ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID GROUP BY c.CategoryName HAVING largestPrice > 100 ORDER
          BY largestPrice desc ;
    errors: 1
    expression: ' Products.map(p => ({ category: p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice > 100).sort(p => desc(p.largestPrice))'
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
        result:
          - category: Beverages
            largestPrice: '263.5000'
          - category: Meat/Poultry
            largestPrice: '123.7900'
      - database: postgres
        error: 'run: select error: TypeError: Cannot read property ''rows'' of undefined'
  - name: groupBy 11
    lambda: >-
      () => Products.filter(p => p.price > 5).map(p => ({ category:
      p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice
      > 50).sort(p => desc(p.largestPrice))
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          largestPrice > 50 ORDER BY largestPrice desc ;
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(p.UnitPrice) AS
          [largestPrice] FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          largestPrice > 50 ORDER BY largestPrice desc ;
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS
          `largestPrice` FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          largestPrice > 50 ORDER BY largestPrice desc ;
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          largestPrice > 50 ORDER BY largestPrice desc ;
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(p.UnitPrice) AS
          "largestPrice" FROM Products p INNER JOIN Categories c ON c.CategoryID
          = p.CategoryID WHERE p.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          largestPrice > 50 ORDER BY largestPrice desc ;
    errors: 1
    expression: ' Products.filter(p => p.price > 5).map(p => ({ category: p.category.name, largestPrice: max(p.price) })).having(p => p.largestPrice > 50).sort(p => desc(p.largestPrice))'
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
        result:
          - category: Beverages
            largestPrice: '263.5000'
          - category: Meat/Poultry
            largestPrice: '123.7900'
          - category: Confections
            largestPrice: '81.0000'
          - category: Seafood
            largestPrice: '62.5000'
          - category: Dairy Products
            largestPrice: '55.0000'
          - category: Produce
            largestPrice: '53.0000'
      - database: postgres
        error: 'run: select error: TypeError: Cannot read property ''rows'' of undefined'
errors: 3
