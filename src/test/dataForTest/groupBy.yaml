name: groupBy
schema: northwind
context:
  a:
    id: 1
test:
  - name: groupBy 1
    sentences:
      - dialect: mariadb
        sentence: 'SELECT MAX(n.UnitPrice) AS `maxPrice` FROM Products n  '
      - dialect: mssql
        sentence: 'SELECT MAX(n.UnitPrice) AS [maxPrice] FROM Products n  '
      - dialect: mysql
        sentence: 'SELECT MAX(n.UnitPrice) AS `maxPrice` FROM Products n  '
      - dialect: oracle
        sentence: 'SELECT MAX(n.UnitPrice) AS "maxPrice" FROM Products n  '
      - dialect: postgres
        sentence: 'SELECT MAX(n.UnitPrice) AS "maxPrice" FROM Products n  '
    errors: 0
    expression: 'northwind_1.Products.map(p => ({ maxPrice: max(p.price) }))'
    completeExpression: northwind_1.Products.map(p=>{maxPrice:max(p.price)})
    model:
      maxPrice: any
    parameters: []
    fields:
      - name: maxPrice
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - maxPrice: 263.5
  - name: groupBy 2
    sentences:
      - dialect: mariadb
        sentence: 'SELECT MIN(n.UnitPrice) AS `minPrice` FROM Products n  '
      - dialect: mssql
        sentence: 'SELECT MIN(n.UnitPrice) AS [minPrice] FROM Products n  '
      - dialect: mysql
        sentence: 'SELECT MIN(n.UnitPrice) AS `minPrice` FROM Products n  '
      - dialect: oracle
        sentence: 'SELECT MIN(n.UnitPrice) AS "minPrice" FROM Products n  '
      - dialect: postgres
        sentence: 'SELECT MIN(n.UnitPrice) AS "minPrice" FROM Products n  '
    errors: 0
    expression: 'northwind_1.Products.map(p => ({ minPrice: min(p.price) }))'
    completeExpression: northwind_1.Products.map(p=>{minPrice:min(p.price)})
    model:
      minPrice: any
    parameters: []
    fields:
      - name: minPrice
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - minPrice: 2.5
  - name: groupBy 3
    sentences:
      - dialect: mariadb
        sentence: 'SELECT SUM(n.UnitPrice) AS `total` FROM Products n  '
      - dialect: mssql
        sentence: 'SELECT SUM(n.UnitPrice) AS [total] FROM Products n  '
      - dialect: mysql
        sentence: 'SELECT SUM(n.UnitPrice) AS `total` FROM Products n  '
      - dialect: oracle
        sentence: 'SELECT SUM(n.UnitPrice) AS "total" FROM Products n  '
      - dialect: postgres
        sentence: 'SELECT SUM(n.UnitPrice) AS "total" FROM Products n  '
    errors: 0
    expression: 'northwind_1.Products.map(p => ({ total: sum(p.price) }))'
    completeExpression: northwind_1.Products.map(p=>{total:sum(p.price)})
    model:
      total: any
    parameters: []
    fields:
      - name: total
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - total: 2222.71
  - name: groupBy 4
    sentences:
      - dialect: mariadb
        sentence: 'SELECT AVG(n.UnitPrice) AS `average` FROM Products n  '
      - dialect: mssql
        sentence: 'SELECT AVG(n.UnitPrice) AS [average] FROM Products n  '
      - dialect: mysql
        sentence: 'SELECT AVG(n.UnitPrice) AS `average` FROM Products n  '
      - dialect: oracle
        sentence: 'SELECT AVG(n.UnitPrice) AS "average" FROM Products n  '
      - dialect: postgres
        sentence: 'SELECT AVG(n.UnitPrice) AS "average" FROM Products n  '
    errors: 1
    expression: 'northwind_1.Products.map(p => ({ average: avg(p.price) }))'
    completeExpression: northwind_1.Products.map(p=>{average:avg(p.price)})
    model:
      average: any
    parameters: []
    fields:
      - name: average
        type: any
    executions:
      - database: mysql
      - database: postgres
        error: not equal mysql
        result:
          - average: 28.866363636363637
    result:
      - average: 28.86636364
  - name: groupBy 5
    sentences:
      - dialect: mariadb
        sentence: 'SELECT COUNT(1) AS `count` FROM Products n  '
      - dialect: mssql
        sentence: 'SELECT COUNT(1) AS [count] FROM Products n  '
      - dialect: mysql
        sentence: 'SELECT COUNT(1) AS `count` FROM Products n  '
      - dialect: oracle
        sentence: 'SELECT COUNT(1) AS "count" FROM Products n  '
      - dialect: postgres
        sentence: 'SELECT COUNT(1) AS "count" FROM Products n  '
    errors: 0
    expression: 'northwind_1.Products.map(p => ({ count: count(1) }))'
    completeExpression: northwind_1.Products.map(p=>{count:count(1)})
    model:
      count: any
    parameters: []
    fields:
      - name: count
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - count: 77
  - name: groupBy 6
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT n.CategoryID AS `category`, MAX(n.UnitPrice) AS `largestPrice`
          FROM Products n  GROUP BY n.CategoryID 
      - dialect: mssql
        sentence: >-
          SELECT n.CategoryID AS [category], MAX(n.UnitPrice) AS [largestPrice]
          FROM Products n  GROUP BY n.CategoryID 
      - dialect: mysql
        sentence: >-
          SELECT n.CategoryID AS `category`, MAX(n.UnitPrice) AS `largestPrice`
          FROM Products n  GROUP BY n.CategoryID 
      - dialect: oracle
        sentence: >-
          SELECT n.CategoryID AS "category", MAX(n.UnitPrice) AS "largestPrice"
          FROM Products n  GROUP BY n.CategoryID 
      - dialect: postgres
        sentence: >-
          SELECT n.CategoryID AS "category", MAX(n.UnitPrice) AS "largestPrice"
          FROM Products n  GROUP BY n.CategoryID 
    errors: 1
    expression: >-
      northwind_1.Products.map(p => ({ category: p.categoryId, largestPrice:
      max(p.price) }))
    completeExpression: >-
      northwind_1.Products.map(p=>{category:p.categoryId,largestPrice:max(p.price)})
    model:
      category: integer
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: integer
      - name: largestPrice
        type: any
    executions:
      - database: mysql
      - database: postgres
        error: not equal mysql
        result:
          - category: 3
            largestPrice: 81
          - category: 5
            largestPrice: 38
          - category: 4
            largestPrice: 55
          - category: 6
            largestPrice: 123.79
          - category: 2
            largestPrice: 43.9
          - category: 7
            largestPrice: 53
          - category: 1
            largestPrice: 263.5
          - category: 8
            largestPrice: 62.5
    result:
      - category: 1
        largestPrice: 263.5
      - category: 2
        largestPrice: 43.9
      - category: 3
        largestPrice: 81
      - category: 4
        largestPrice: 55
      - category: 5
        largestPrice: 38
      - category: 6
        largestPrice: 123.79
      - category: 7
        largestPrice: 53
      - category: 8
        largestPrice: 62.5
  - name: groupBy 7
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName 
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(n.UnitPrice) AS
          [largestPrice] FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName 
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName 
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName 
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName 
    errors: 1
    expression: >-
      northwind_1.Products.map(p => ({ category: p.category.name, largestPrice:
      max(p.price) }))
    completeExpression: >-
      northwind_1.Products.map(p=>{category:p.category.name,largestPrice:max(p.price)})
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
      - database: postgres
        error: not equal mysql
        result:
          - category: Grains/Cereals
            largestPrice: 38
          - category: Beverages
            largestPrice: 263.5
          - category: Dairy Products
            largestPrice: 55
          - category: Seafood
            largestPrice: 62.5
          - category: Produce
            largestPrice: 53
          - category: Condiments
            largestPrice: 43.9
          - category: Meat/Poultry
            largestPrice: 123.79
          - category: Confections
            largestPrice: 81
    result:
      - category: Beverages
        largestPrice: 263.5
      - category: Condiments
        largestPrice: 43.9
      - category: Confections
        largestPrice: 81
      - category: Dairy Products
        largestPrice: 55
      - category: Grains/Cereals
        largestPrice: 38
      - category: Meat/Poultry
        largestPrice: 123.79
      - category: Produce
        largestPrice: 53
      - category: Seafood
        largestPrice: 62.5
  - name: groupBy 8
    context: a
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT n.ProductName AS `name`, n.UnitPrice AS `source`,
          ABS(n.UnitPrice) AS `result` FROM Products n  WHERE n.ProductID = ? 
      - dialect: mssql
        sentence: >-
          SELECT n.ProductName AS [name], n.UnitPrice AS [source],
          ABS(n.UnitPrice) AS [result] FROM Products n  WHERE n.ProductID = :id 
      - dialect: mysql
        sentence: >-
          SELECT n.ProductName AS `name`, n.UnitPrice AS `source`,
          ABS(n.UnitPrice) AS `result` FROM Products n  WHERE n.ProductID = ? 
      - dialect: oracle
        sentence: >-
          SELECT n.ProductName AS "name", n.UnitPrice AS "source",
          ABS(n.UnitPrice) AS "result" FROM Products n  WHERE n.ProductID = :id 
      - dialect: postgres
        sentence: >-
          SELECT n.ProductName AS "name", n.UnitPrice AS "source",
          ABS(n.UnitPrice) AS "result" FROM Products n  WHERE n.ProductID = $1 
    errors: 0
    expression: >-
      northwind_1.Products.filter(p => p.id === id).map(p => ({ name: p.name,
      source: p.price, result: abs(p.price) }))
    completeExpression: >-
      northwind_1.Products.filter(p=>(p.id===id)).map(p=>{name:p.name,source:p.price,result:abs(p.price)})
    model:
      name: string
      source: decimal
      result: any
    parameters:
      - name: id
        type: integer
        value: 1
    fields:
      - name: name
        type: string
      - name: source
        type: decimal
      - name: result
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - name: Chai
        source: 18
        result: 18
  - name: groupBy 9
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100 
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(n.UnitPrice) AS
          [largestPrice] FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100 
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100 
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100 
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100 
    errors: 0
    expression: >-
      northwind_1.Products.having(p => max(p.price) > 100).map(p => ({ category:
      p.category.name, largestPrice: max(p.price) }))
    completeExpression: >-
      northwind_1.Products.having(p=>(max(p.price)>100)).map(p=>{category:p.category.name,largestPrice:max(p.price)})
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - category: Beverages
        largestPrice: 263.5
      - category: Meat/Poultry
        largestPrice: 123.79
  - name: groupBy 10
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100
          ORDER BY `largestPrice` desc 
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(n.UnitPrice) AS
          [largestPrice] FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100
          ORDER BY [largestPrice] desc 
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100
          ORDER BY `largestPrice` desc 
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100
          ORDER BY "largestPrice" desc 
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID GROUP BY c.CategoryName HAVING MAX(n.UnitPrice) > 100
          ORDER BY "largestPrice" desc 
    errors: 0
    expression: >-
      northwind_1.Products.having(p => max(p.price) > 100).map(p => ({ category:
      p.category.name, largestPrice: max(p.price) })).sort(p =>
      desc(p.largestPrice))
    completeExpression: >-
      northwind_1.Products.having(p=>(max(p.price)>100)).map(p=>{category:p.category.name,largestPrice:max(p.price)}).sort(p=>desc(p.largestPrice))
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - category: Beverages
        largestPrice: 263.5
      - category: Meat/Poultry
        largestPrice: 123.79
  - name: groupBy 11
    sentences:
      - dialect: mariadb
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID WHERE n.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          MAX(n.UnitPrice) > 50 ORDER BY `largestPrice` desc 
      - dialect: mssql
        sentence: >-
          SELECT c.CategoryName AS [category], MAX(n.UnitPrice) AS
          [largestPrice] FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID WHERE n.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          MAX(n.UnitPrice) > 50 ORDER BY [largestPrice] desc 
      - dialect: mysql
        sentence: >-
          SELECT c.CategoryName AS `category`, MAX(n.UnitPrice) AS
          `largestPrice` FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID WHERE n.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          MAX(n.UnitPrice) > 50 ORDER BY `largestPrice` desc 
      - dialect: oracle
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID WHERE n.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          MAX(n.UnitPrice) > 50 ORDER BY "largestPrice" desc 
      - dialect: postgres
        sentence: >-
          SELECT c.CategoryName AS "category", MAX(n.UnitPrice) AS
          "largestPrice" FROM Products n INNER JOIN Categories c ON c.CategoryID
          = n.CategoryID WHERE n.UnitPrice > 5 GROUP BY c.CategoryName HAVING
          MAX(n.UnitPrice) > 50 ORDER BY "largestPrice" desc 
    errors: 0
    expression: >-
      northwind_1.Products.filter(p => p.price > 5).having(p => max(p.price) >
      50).map(p => ({ category: p.category.name, largestPrice: max(p.price)
      })).sort(p => desc(p.largestPrice))
    completeExpression: >-
      northwind_1.Products.filter(p=>(p.price>5)).having(p=>(max(p.price)>50)).map(p=>{category:p.category.name,largestPrice:max(p.price)}).sort(p=>desc(p.largestPrice))
    model:
      category: string
      largestPrice: any
    parameters: []
    fields:
      - name: category
        type: string
      - name: largestPrice
        type: any
    executions:
      - database: mysql
      - database: postgres
    result:
      - category: Beverages
        largestPrice: 263.5
      - category: Meat/Poultry
        largestPrice: 123.79
      - category: Confections
        largestPrice: 81
      - category: Seafood
        largestPrice: 62.5
      - category: Dairy Products
        largestPrice: 55
      - category: Produce
        largestPrice: 53
errors: 3
