_extends: [SQL]
ddl:
  objects: |
    SELECT 
      CASE
        WHEN t.table_type = 'BASE TABLE' THEN 'table'
        WHEN t.table_type = 'VIEW' THEN 'view'
        ELSE 'unknown'
      END AS "type",
      t.table_name AS "name",
      ts.tablespace_name AS "tablespace",
      pg_catalog.obj_description(t.table_name::regclass, 'pg_class') AS "comment"
    FROM 
      information_schema.tables t
    JOIN (
      SELECT 
        tablename AS table_name,
        COALESCE(tablespace, 'pg_default') AS tablespace_name
      FROM 
        pg_tables 
      WHERE 
        schemaname = current_schema
    ) AS ts 
    ON 
      ts.table_name = t.table_name
    WHERE 
      t.table_catalog = current_catalog
      AND t.table_schema = current_schema
      AND t.table_type IN ('BASE TABLE', 'VIEW')
  tables: |
      SELECT
        t.table_name AS "tableName",
        ts.tablespace_name AS "tablespace",
        c.column_name AS "columnName",
        c.data_type AS "dbType",
        c.is_nullable = 'NO' AS "required",
        c.is_identity AS "isIdentity",
        (pg_get_serial_sequence(t.table_name, lower(c.column_name)) IS NOT NULL) AS "autoIncrement",
        c.character_maximum_length AS "length",
        c.numeric_precision AS "precision",
        c.numeric_scale AS "scale",
        c.datetime_precision AS "time"
      FROM 
        information_schema.tables t
      JOIN 
        information_schema.columns c ON t.table_name = c.table_name
      JOIN (
        SELECT 
          tablename AS table_name,
          COALESCE(tablespace, 'pg_default') AS tablespace_name
        FROM 
          pg_tables 
        WHERE 
          schemaname = current_schema
      ) AS ts 
      ON 
        ts.table_name = t.table_name
      WHERE 
        t.table_catalog = current_catalog
        AND t.table_schema = current_schema
        AND c.table_catalog = current_catalog
        AND c.table_schema = current_schema
        AND t.table_type = 'BASE TABLE'
        AND t.table_name IN ({names})
  views: |
    SELECT
      t.table_name AS "tableName",
      ts.tablespace_name AS "tablespace",
      c.column_name AS "columnName",
      c.data_type AS "dbType",
      c.is_nullable = 'NO' AS "required",
      c.is_identity AS "isIdentity",
      (pg_get_serial_sequence(t.table_name, lower(c.column_name)) IS NOT NULL) AS "autoIncrement",
      c.character_maximum_length AS "length",
      c.numeric_precision AS "precision",
      c.numeric_scale AS "scale",
      c.datetime_precision AS "time"
    FROM 
      information_schema.tables t
    JOIN 
      information_schema.columns c ON t.table_name = c.table_name
    JOIN (
      SELECT 
        tablename AS table_name,
        COALESCE(tablespace, 'pg_default') AS tablespace_name
      FROM 
        pg_tables 
      WHERE 
        schemaname = current_schema
    ) AS ts 
    ON 
      ts.table_name = t.table_name
    WHERE 
      t.table_catalog = current_catalog
      AND t.table_schema = current_schema
      AND c.table_catalog = current_catalog
      AND c.table_schema = current_schema
      AND t.table_type = 'VIEW'
      AND t.table_name IN ({names})
  primaryKeys: |
    SELECT
      tc.table_name AS "tableName",
      kcu.column_name AS "columnName",
      tc.constraint_name AS "constraintName"
    FROM 
      information_schema.table_constraints tc
    JOIN 
      information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE 
      tc.constraint_type = 'PRIMARY KEY'
      AND tc.table_catalog = current_catalog
      AND tc.table_schema = current_schema
      AND tc.table_name IN ({tableNames})
  uniqueKeys: |
    SELECT
      tc.table_name AS "tableName",
      kcu.column_name AS "columnName",
      tc.constraint_name AS "constraintName"
    FROM 
      information_schema.table_constraints tc
    JOIN 
      information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE 
      tc.constraint_type = 'UNIQUE'
      AND tc.table_catalog = current_catalog
      AND tc.table_schema = current_schema
      AND tc.table_name IN ({tableNames})
  foreignKeys: |
    SELECT
      tc.table_name AS "tableName",
      kcu.column_name AS "columnName",
      ccu.table_name AS "refTableName",
      ccu.column_name AS "refColumnName",
      tc.constraint_name AS "constraintName"
    FROM 
      information_schema.table_constraints tc
    JOIN 
      information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    JOIN 
      information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name
    WHERE 
      tc.constraint_type = 'FOREIGN KEY'
      AND tc.table_catalog = current_catalog
      AND tc.table_schema = current_schema
      AND tc.table_name IN ({tableNames})
  indexes: |
    SELECT
      t.relname AS "tableName",
      i.relname AS "indexName",
      a.attname AS "columnName",
      ix.indisunique AS "isUnique",
      ix.indisprimary AS "isPrimary"
    FROM 
      pg_class t
    JOIN 
      pg_index ix ON t.oid = ix.indrelid
    JOIN 
      pg_class i ON i.oid = ix.indexrelid
    JOIN 
      pg_attribute a ON a.attrelid = t.oid
    WHERE 
      t.relkind = 'r'
      AND t.relname IN ({tableNames})
      AND a.attnum = ANY(ix.indkey)
      AND ix.indisunique = false
      AND ix.indisprimary = false
  sequences: |
    SELECT
      sequence_name AS "sequenceName",
      start_value AS "startValue",
      increment AS "increment"
    FROM 
      information_schema.sequences
    WHERE 
      sequence_catalog = current_catalog
      AND sequence_schema = current_schema
