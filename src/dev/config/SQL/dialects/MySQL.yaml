_extends: [SQL]
dbTypes:
  text: LONGTEXT
ddl:
  dropIndex: "DROP INDEX {name} ON {table}"
  objects: |
    SELECT CASE
        WHEN t.table_type = 'BASE TABLE' THEN 'table'
        WHEN t.table_type = 'VIEW' THEN 'view'
        ELSE 'unknown'
      END AS type,
      t.table_name AS name,
      IFNULL(ts.tablespace_name, 'pg_default') AS tablespace,
      CAST(obj_description(CONCAT('public.', t.table_name), 'pg_class') AS CHAR) AS comment
    FROM information_schema.tables t
    JOIN (SELECT tablename AS table_name,
          COALESCE(tablespace_name, 'pg_default') AS tablespace_name
          FROM information_schema.tables 
          WHERE table_schema = DATABASE()
      ) as ts ON ts.table_name = t.table_name
    WHERE t.table_schema = DATABASE()
      AND t.table_type IN ('BASE TABLE', 'VIEW')
  tables: |
        SELECT
          t.table_name AS tableName,
          ts.tablespace_name AS tablespace,
          c.column_name AS columnName,
          c.data_type AS dbType,
          c.is_nullable = 'NO' AS required,
          c.extra = 'auto_increment' AS isIdentity,
          (EXISTS(SELECT column_default 
                   FROM information_schema.columns 
                   WHERE table_name = t.table_name 
                   AND column_name = c.column_name 
                   AND column_default LIKE 'nextval%')) AS autoIncrement,
          c.character_maximum_length AS length,
          c.numeric_precision AS precision,
          c.numeric_scale AS scale,
          c.datetime_precision AS time
        FROM information_schema.tables t
        JOIN information_schema.columns c ON t.table_name = c.table_name
        JOIN (SELECT tablename AS table_name,
          COALESCE(tablespace_name, 'pg_default') AS tablespace_name
          FROM information_schema.tables 
          WHERE table_schema = DATABASE()
          ) as ts ON ts.table_name = t.table_name
        WHERE t.table_schema = DATABASE()
          AND t.table_type = 'BASE TABLE'
          AND t.table_name IN ({names})
  views: |
    SELECT
      t.table_name AS tableName,
      ts.tablespace_name AS tablespace,
      c.column_name AS columnName,
      c.data_type AS dbType,
      c.is_nullable = 'NO' AS required,
      c.extra = 'auto_increment' AS isIdentity,
      (EXISTS(SELECT column_default 
               FROM information_schema.columns 
               WHERE table_name = t.table_name 
               AND column_name = c.column_name 
               AND column_default LIKE 'nextval%')) AS autoIncrement,
      c.character_maximum_length AS length,
      c.numeric_precision AS precision,
      c.numeric_scale AS scale,
      c.datetime_precision AS time    
    FROM information_schema.tables t
    JOIN information_schema.columns c ON t.table_name = c.table_name
    JOIN (SELECT tablename AS table_name,
      COALESCE(tablespace_name, 'pg_default') AS tablespace_name
      FROM information_schema.tables 
      WHERE table_schema = DATABASE()
      ) as ts ON ts.table_name = t.table_name
    WHERE t.table_schema = DATABASE()
      AND t.table_type = 'VIEW'
      AND t.table_name IN ({names})
  primaryKeys: |
    SELECT
      tc.table_name AS tableName,
      kcu.column_name AS columnName,
      tc.constraint_name AS constraintName
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.constraint_type = 'PRIMARY KEY'
      AND tc.table_schema = DATABASE()
      AND tc.table_name IN ({tableNames})
  uniqueKeys: |
    SELECT
      tc.table_name AS tableName,
      kcu.column_name AS columnName,
      tc.constraint_name AS constraintName
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.constraint_type = 'UNIQUE'
      AND tc.table_schema = DATABASE()
      AND tc.table_name IN ({tableNames})
  foreignKeys: |
    SELECT
      tc.table_name AS "tableName",
      kcu.column_name AS "columnName",
      ccu.table_name AS "refTableName",
      ccu.column_name AS "refColumnName",
      tc.constraint_name AS "constraintName"
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name
    WHERE tc.constraint_type = 'FOREIGN KEY'
      AND tc.table_catalog = current_catalog
      AND tc.table_schema = current_schema
      AND tc.table_name IN ({tableNames})
  indexes: |
    SELECT
      t.table_name AS tableName,
      i.index_name AS indexName,
      a.column_name AS columnName,
      NOT i.non_unique AS isUnique,
      CASE
        WHEN i.index_name = 'PRIMARY' THEN TRUE
        ELSE FALSE
      END AS isPrimary
    FROM information_schema.tables t
    JOIN information_schema.statistics i ON t.table_schema = i.table_schema AND t.table_name = i.table_name
    JOIN information_schema.columns a ON t.table_schema = a.table_schema AND t.table_name = a.table_name
    WHERE t.table_type = 'BASE TABLE'
      AND t.table_name IN ({tableNames})
      AND FIND_IN_SET(a.ordinal_position, i.column_name) > 0
      AND i.non_unique = 1
      AND i.index_name != 'PRIMARY'
  sequences: |
    SELECT
      sequence_name AS sequenceName,
      start_value AS startValue,
      increment AS increment
    FROM information_schema.SEQUENCES
    WHERE sequence_schema = DATABASE()
dml:
  delete: DELETE {alias} FROM {name} AS {alias}
  bulkInsert: INSERT INTO {name}({fields}) VALUES ?
others:
  delimiter: "`{name}`"
  variable: "?"
functions:
  numeric:
    atan2: "ATAN({0},{1})"
    cosh: "((EXP({0}) + EXP(-{0})) / 2)"
    remainder: "({0} - {1}*ROUND({0}/{1}))"
    sinh: "((EXP({0}) - EXP(-{0})) / 2)"
    tanh: "(EXP(2*{0}) - 1)/(EXP(2*{0}) + 1)"
    trunc: "TRUNCATE({0},{1})"
    toNumber: "CONVERT({0}, DECIMAL)"
  string:
    chr: "CHAR({0} USING ASCII)"
    initcap: "INITCAP({0})" #  https://stackoverflow.com/questions/12364086/how-can-i-achieve-initcap-functionality-in-mysql
    length: "CHAR_LENGTH({0})"
    # https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html#function_convert
    toString: "CONVERT({0}, CHAR)"
    parse: "CONVERT({0}, JSON)"
  #   regExpReplace: 'REGEXP_REPLACE({0},{1})'
  #   regExpSubstr: 'REGEXP_SUBSTR({0},{1})'
  #   replace: 'REPLACE({0},{1},{2})'
  dateTime:
    # https://www.w3schools.com/jsref/jsref_obj_date.asp
    # https://phoenixnap.com/kb/mysql-date-function#ftoc-heading-8
    curTime: "CURTIME()"
    today: "CURDATE()"
    now: "NOW()"
    # time: 'TIME({0})'
    # date: 'DATE({0})'
    date: "CONVERT({0}, DATE)"
    dateTime: "CONVERT({0}, DATETIME)"
    time: "CONVERT({0}, TIME)"
    year: "EXTRACT(YEAR FROM {0})"
    month: "EXTRACT(MONTH FROM {0})"
    day: "DAYOFMONTH({0})"
    weekday: "DAYOFWEEK({0})"
    hours: "EXTRACT(HOUR FROM {0})"
    minutes: "EXTRACT(MINUTE FROM {0})"
    seconds: "EXTRACT(SECOND FROM {0})"
    millisecond: "ROUND(EXTRACT(MICROSECOND FROM {0})/1000,0)"
    addYear: "DATE_ADD({0}, INTERVAL {1} YEAR)"
    addMonth: "DATE_ADD({0}, INTERVAL {1} MONTH)"
    addDay: "DATE_ADD({0}, INTERVAL {1} DAY)"
    addHours: "DATE_ADD({0}, INTERVAL {1} HOUR)"
    addMinutes: "DATE_ADD({0}, INTERVAL {1} MINUTE)"
    addSeconds: "DATE_ADD({0}, INTERVAL {1} SECOND)"
    addMillisecond: "DATE_ADD({0}, INTERVAL ({1} * 1000) MICROSECOND)"
    addTime: "ADDTIME({0},{1})"    
    subtractTime: "SUBTIME({0},{1})"
    dayDiff: "DATEDIFF({0},{1})"
    hourDiff: "TIMESTAMPDIFF(HOUR, {1},{0})"
    secondDiff: "TIMESTAMPDIFF(SECOND, {1},{0})"
    millisecondDiff: "ROUND(TIMESTAMPDIFF(MICROSECOND, {1},{0})/1000,0)"
    dateDiff: "DATEDIFF({0},{1})"
    timeDiff: "TIMEDIFF({0},{1})"   
    dayToDate: "DATE_FORMAT(FROM_UNIXTIME({0}*24*3600), '%Y-%m-%dT%TZ')"
    hourToDate: "DATE_FORMAT(FROM_UNIXTIME({0}*3600), '%Y-%m-%dT%TZ')"
    secondToDate: "DATE_FORMAT(FROM_UNIXTIME({0}), '%Y-%m-%dT%TZ')"
    millisecondToDate: "DATE_FORMAT(FROM_UNIXTIME({0}/1000), '%Y-%m-%dT%TZ')"
    dateToString: DATE_FORMAT({0}, '%Y-%m-%dT%TZ')  
  metadata:
    user: "CURRENT_USER()"
    database: "DATABASE()"
  null:
    nvl: "IFNULL({0},{1})"
    nvl2: "(CASE WHEN {0} IS NOT NULL THEN {1} ELSE {2} END)" # https://www.simplilearn.com/tutorials/sql-tutorial/nvl-in-sql
  multiple:
    concat: "CONCAT({accumulated},{value})" # https://www.w3schools.com/Sql/func_mysql_concat.asp
